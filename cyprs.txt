    npx cypress open

...................................
cy.contains('...') (The "Finder")
This command's only job is to find an element in the HTML. It scans the entire document (even hidden parts) for the text "Please select a valid image file".

The key detail: It will find the element even if it's hidden with display: none. It's a good detective; it can find someone hiding in a closet.

By itself, this command only confirms the text exists somewhere in the HTML.

......................................................................................................................................
2. .should('be.visible') (The "Checker")
This command is an assertion. Its only job is to check the element that the detective just found.

The security guard takes the suspect from the detective and asks, "Okay, you found him... but is he actually out here on the public-facing website where a user can see him?"


.................................................................................................
You got it. This is the most powerful command in Cypress, so it's worth a minute.

Think of `cy.intercept()` as your own personal **spy agency** for your app.

Your frontend (React) and your backend (Node.js) talk to each other over a "phone line" (the network). `cy.intercept()` lets you tap that phone line.

It has three main "missions" or jobs:

### 1\. Job \#1: The "Waitress" (Solving Flakiness)

This is what you're doing right now. It's the most common use.

  * **The Problem:** You click "Submit," and your test immediately checks for "Success\!" But your backend takes 800ms to respond. Your test checks at 100ms, fails, and you're left screaming, "But it works on my machine\!" This is a **flaky test**.
  * **The Solution:**
      * **`cy.intercept('POST', '.../api/...').as('addLocation')`**
          * This tells your spy, "Put a 'bug' on the phone line. When you hear a `POST` to that URL, give it the codename **`@addLocation`**."
      * **`cy.wait('@addLocation')`**
          * This tells your test, "Stop. Do not move. **Wait** until your spy with the codename **`@addLocation`** reports that the call has *finished*."

This makes your test 100% reliable. It will wait 50ms or 5 seconds. It doesn't care. It just waits for the signal.

### 2\. Job \#2: The "Detective" (Asserting on Data)

This is where you check what's *in* the phone call.

  * **The Goal:** You want to test a failure. You want to *prove* that when you send a bad password, your backend sends back a `401` error.

  * **The Test:**

    ```javascript
    it('should fail with a 401 on bad password', () => {
      // 1. Set up the spy.
      cy.intercept('POST', '.../api/v1/user/login').as('loginRequest');
      
      // 2. Do the bad action.
      cy.visit('/login');
      cy.get('input[name="email"]').type('testUser@gmail.com');
      cy.get('input[name="password"]').type('BAD_PASSWORD');
      cy.get('button[type="submit"]').click();

      // 3. Wait for the spy and then interrogate it.
      cy.wait('@loginRequest').then((interception) => {
        // Now you can check the response from your backend!
        expect(interception.response.statusCode).to.eq(401);
      });
      
      // 4. Also check the UI.
      cy.contains('Invalid email or password').should('be.visible');
    });
    ```

### 3\. Job \#3: The "Impostor" (Mocking the Backend)

This is the most powerful move. You **fake the backend** entirely. This lets you test rare error states without *actually* breaking your server.

  * **The Goal:** You want to test what happens if your server has a total meltdown (a `500 Internal Server Error`).

  * **The Test:**

    ```javascript
    it('should show a "Server Down" message on a 500 error', () => {
      // 1. Set up the spy to be an IMPOSTOR.
      // Tell it to intercept the call and reply *itself*.
      cy.intercept('POST', '.../api/v1/fromLocation', {
        statusCode: 500,
        body: { message: 'The database exploded' }
      }).as('mockError');
      
      // 2. Visit the page and submit the form.
      cy.visit('/add-location');
      cy.get('input[name="locationName"]').type('This will fail');
      cy.get('button[type="submit"]').click();
      
      // 3. Wait for the (fake) response.
      cy.wait('@mockError');

      // 4. Check that your frontend correctly showed the 500 error message.
      cy.contains('Error: The database exploded').should('be.visible');
    });
    ```

You just tested a complete server meltdown without even touching your Node.js code.

-----

**TL;DR:** `cy.intercept()` is your secret agent. You use it to **Wait** (for reliability), **Assert** (to check the API response), or **Mock** (to fake the backend).

This is what makes Cypress so much more powerful than just a UI clicker. You're testing the *entire* application, not just the skin.